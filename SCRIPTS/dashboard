#!/bin/env python3
# Requirements: python3 -m venv ~/.venv && ~/.venv/bin/pip3 install caldav vobject colorama
# Usage: ~/.venv/bin/python3 ./dashboard
# Environment variables:
# CALDAV_URL
# CALDAV_USERNAME
# CALDAV_PASSWORD
# CALDAV_MAX_PRIORITY
# CALDAV_EVENTS_MAX_DAYS_IN_FUTURE
# GITLAB_TOKEN
# MAX_LINES
# GITEA_URL
# GITEA_TOKEN
# TODO_TXT_PATH
# TTRSS_URL
# TTRSS_USERNAME
# TTRSS_PASSWORD
# TTRSS_LIMIT
# BACKUP_STATE_FILE
# IMAP_FLAGGED_FOLDERS_LIST # comma-separated list
# IMAP_UNREAD_FOLDERS_LIST # comma-separated list
# IMAP_USERNAME
# IMAP_PASSWORD
# IMAP_SERVER
# REQUESTS_TIMEOUT

import sys
import argparse
import datetime
import email
import imaplib
import json
import os
import time

import caldav
import colorama
import icalendar
import requests
import urllib3

# Disable SSL warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# load config from environment
OS_ENVIRON=os.environ
REQUESTS_TIMEOUT=int(OS_ENVIRON['REQUESTS_TIMEOUT']) # global

def print_title(text):
    """Print section title to screen"""
    print(f'{colorama.Fore.GREEN}####### {text}{colorama.Style.RESET_ALL}')

def format_bullet_point(symbol, color, text):
    """Format a string as a bullet point"""
    formatted = f'{color}{symbol} {colorama.Style.RESET_ALL}{text}'
    return formatted

def format_list(items, max_lines):
    """"return the first items of a list as text on multiple lines"""
    first_items = items[:max_lines]
    return "\n".join(first_items)

def get_imap_subjects(conn, folder, criterion):
    """get subjects of messages matching the search criterion in a folder"""
    prefix = folder.replace('INBOX/', '') + ': '
    #prefix = '' # hide folder names

    conn.select(folder, readonly=True)
    _, imap_response = conn.search(None, criterion)
    message_uids = imap_response[0].split()
    messages = []
    for message_uid in message_uids:
        _, message_data = conn.fetch(message_uid, '(BODY.PEEK[HEADER])')
        for response_part in message_data:
            if isinstance(response_part, tuple):
                msg = email.message_from_bytes(response_part[1])
                decoded_header, encoding = email.header.decode_header(msg['Subject'])[0]
                if isinstance(decoded_header, bytes):
                    subject = decoded_header.decode(encoding).replace('\r', '').replace('\n', '')
                else:
                    subject = decoded_header.replace('\r', '').replace('\n', '')
                message = prefix + subject
                messages.append(message)
    return messages


def get_unread_mail(imap_server, imap_port,
                     imap_username, imap_password, imap_folders_list):
    """show a list of unread mail in an IMAP mailbox"""
    all_messages = []
    conn = imaplib.IMAP4_SSL(imap_server, imap_port)
    conn.login(imap_username, imap_password)
    for folder in imap_folders_list.split(','):
        all_messages.extend(get_imap_subjects(conn, folder, '(UNSEEN)'))
    conn.close()
    conn.logout()
    return all_messages


def get_flagged_mail(imap_server, imap_port,
                     imap_username, imap_password, imap_folders_list):
    """show a list of flagged mail in an IMAP mailbox"""
    all_messages = []
    conn = imaplib.IMAP4_SSL(imap_server, imap_port)
    conn.login(imap_username, imap_password)
    for folder in imap_folders_list.split(','):
        all_messages.extend(get_imap_subjects(conn, folder, '(FLAGGED)'))
    conn.close()
    conn.logout()
    return all_messages


def get_gitlab_issues(gitlab_token, assigned=False, created=False, repos=False):
    """TODO show a list of open github issues assigned to me
    parameters: github_username, github_token"""
    headers = {"PRIVATE-TOKEN": gitlab_token}
    BASE_URL = "https://gitlab.com/api/v4"
    gitlab_issues = []

    if assigned:
        params = {"state": "opened", "scope": "assigned_to_me"}
        url = f"{BASE_URL}/issues"
        response = requests.get(url, headers=headers, params=params, timeout=REQUESTS_TIMEOUT)
        response.raise_for_status()
        issues = response.json()
        for issue in issues:
            gitlab_issues.append(f'{issue["web_url"]} - {issue["title"]}')

    if created:
        print_title("gitlab issues created by you")
        params = {"state": "opened", "scope": "created_by_me"}
        url = f"{BASE_URL}/issues"
        response = requests.get(url, headers=headers, params=params, timeout=REQUESTS_TIMEOUT)
        response.raise_for_status()
        issues = response.json()
        for issue in issues:
            gitlab_issues.append(f'{issue["web_url"]} - {issue["title"]}')

    if repos:
        print_title("gitlab issues in your repos")
        projects_url = f"{BASE_URL}/projects"
        params = {"owned": "true", "per_page": "50", "with_issues_enabled": "true"}
        response = requests.get(projects_url, headers=headers, params=params, timeout=REQUESTS_TIMEOUT)
        response.raise_for_status()
        projects = response.json()

        for project in projects:
            project_id = project['id']
            issues_url = f"{BASE_URL}/projects/{project_id}/issues"
            params = {"state": "opened"}
            response = requests.get(issues_url, headers=headers, params=params, timeout=REQUESTS_TIMEOUT)
            response.raise_for_status()
            issues = response.json()

            if issues:
                for issue in issues:
                    gitlab_issues.append(f'{issue["web_url"]} - {issue["title"]}')

    return gitlab_issues


def get_gitea_issues(gitea_instance_url, gitea_token):
    """show a list of open gitea issues assigned to the specified user
    parameters: gitea_instance_url, gitea_token
    returns: list of issues URLs"""

    url = f"{gitea_instance_url}/api/v1/repos/issues/search"
    params = {
        'state': 'open',
        'assigned': "true",
        'direction': 'desc',
        'sort': 'updated'
    }
    headers = {'Authorization': f'token {gitea_token}'}

    try:
        response = requests.get(url, params=params, headers=headers, verify=False, timeout=REQUESTS_TIMEOUT)
        response.raise_for_status()
        issues = response.json()
        gitea_issues = []
        for issue in issues:
            gitea_issues.append(f'{issue["html_url"]} - {issue["title"]}')

    except requests.exceptions.RequestException as e:
        print(f"Error fetching issues: {e}")
        return []

    return gitea_issues


def get_ttrss_marked(ttrss_url, ttrss_username, ttrss_password, ttrss_limit):
    """List TT-RSS starred articles"""
    # https://tt-rss.org/wiki/ApiReference

    ttrss_session = requests.Session()
    ttrss_login_data = json.dumps({
        "op": "login",
        "user": ttrss_username,
        "password": ttrss_password})
    ttrss_headers = {"Content-Type": "application/json"}

    response = ttrss_session.post(
        ttrss_url + '/api/',
        verify=False,
        headers=ttrss_headers,
        data=ttrss_login_data)
    auth = json.loads(response.text)
    session_id = auth['content']['session_id']

    # Get limit from environment variable or default to 20
    limit = int(ttrss_limit)

    ttrss_query_data = json.dumps({
        "sid": session_id,
        "op": "getHeadlines",
        "feed_id": -1, # starred articles
        "view_mode": "all_articles",
        "feed_dates": "date_reverse",
        "limit": limit})

    response = ttrss_session.post(
        ttrss_url + '/api/',
        verify=False,
        headers=ttrss_headers,
        data=ttrss_query_data)

    data = json.loads(response.text)
    ttrss_marked_articles = []
    for article in data['content']:
        ttrss_marked_articles.append(article['title'])

    return ttrss_marked_articles


def get_todo_list(todo_txt_path):
    """return the contents of todo_txt_path as list items, one per line, removing
       lines starting with #
    """
    with open(todo_txt_path, 'r', encoding="utf-8") as file:
        lines = [line.strip() for line in file.readlines()]
        return [line for line in lines if not line.startswith('#')]

def get_caldav_events(caldav_url, caldav_username, caldav_password, max_days_in_future):
    events = []
    caldav_client = caldav.DAVClient(
        url=caldav_url,
        username=caldav_username,
        password=caldav_password,
        ssl_verify_cert=False)
    caldav_principal = caldav_client.principal()
    caldav_calendar = caldav_principal.calendar(name='Personnel')
    assert caldav_calendar
    now = datetime.datetime.now(datetime.timezone.utc)
    caldav_events = caldav_calendar.search(
        start=now,
        end=now + datetime.timedelta(days=max_days_in_future),
        event=True,
        expand=True,
        sort_keys=('dtstart',))
    for event in caldav_events:
        ical_event = icalendar.Calendar.from_ical(event.data)
        for component in ical_event.walk():
            if component.name == "VEVENT":
                summary = component.get('summary')
                start_datetime = component.get('dtstart').dt
                start = start_datetime.strftime('%a %d/%m %H:%M')
                end_datetime = component.get('dtend').dt
                duration_datetime = end_datetime - start_datetime
                duration = 'h'.join(str(duration_datetime).split(':')[:2])
                out_line = f'{start} {duration} {summary}'
                events.append(out_line)
    return events


def get_caldav_tasks(caldav_url, caldav_username, caldav_password, max_priority=9):
    """Show a list of caldav tasks"""
    todos = []
    caldav_client = caldav.DAVClient(
        url=caldav_url,
        username=caldav_username,
        password=caldav_password,
        ssl_verify_cert=False)
    caldav_principal = caldav_client.principal()
    caldav_calendar = caldav_principal.calendar(name='Personnel')
    assert caldav_calendar
    caldav_todos = caldav_calendar.todos(include_completed=False)
    now = datetime.datetime.now(datetime.timezone.utc)
    for todo in caldav_todos:
        summary = todo.vobject_instance.vtodo.summary.value
        try:
            priority = todo.vobject_instance.vtodo.priority.value
        except AttributeError:
            priority = "9"
        priority_int = int(priority)
        if priority_int > max_priority:
            continue
        # Check if start date exists and is in the past
        try:
            dtstart = todo.vobject_instance.vtodo.dtstart.value
            # Convert to datetime if it's a date object
            if isinstance(dtstart, datetime.date) and not isinstance(dtstart, datetime.datetime):
                dtstart = datetime.datetime.combine(dtstart, datetime.time.min)
            # Make timezone-aware if naive
            if dtstart.tzinfo is None:
                dtstart = dtstart.replace(tzinfo=datetime.timezone.utc)
            if dtstart > now:
                continue
        except AttributeError:
            # If no start date, include the task
            pass

        todos.append(f'{priority} {summary}')
    todos.sort()
    return todos


def check_mtime(file_path, warn_if_older_than_seconds):
    """check if a file last modification time is older than specified number of seconds"""
    if not os.path.exists(file_path):
        out = format_bullet_point('▧', colorama.Fore.RED, f'ERROR: {file_path} does not exist')
        print(out)
        return
    mod_time = os.path.getmtime(file_path)
    current_time = time.time()
    time_diff = current_time - mod_time
    mod_time_readable = datetime.datetime.fromtimestamp(mod_time).strftime('%Y-%m-%d %H:%M:%S')
    if time_diff > warn_if_older_than_seconds:
        out = format_bullet_point('▧', colorama.Fore.RED, f"ERROR: {file_path} last modified: {mod_time_readable})")
    else:
        out = format_bullet_point('▧', colorama.Fore.GREEN, f"{file_path} last modified: {mod_time_readable}")
    print(out)


def print_progress_bar(current, total, bar_length, output_format):
    """Print a progress bar"""
    if output_format == 'cli':
        green = colorama.Fore.GREEN
        white = colorama.Fore.WHITE
        reset = colorama.Style.RESET_ALL
    else: # conky
        green = '${color green}'
        white = '${color white}'
        reset = '${color2}'
    percent = float(current) / total
    blocks = '▅' * int(round(percent * bar_length))
    spaces = '▅' * (bar_length - len(blocks))
    print(f'{green}{blocks}{reset}{spaces}{white} ', end='', flush=True)

def calculate_progress(date_str, total_days):
    """Calculate progress for a date-based period"""
    try:
        start_date = datetime.datetime.strptime(date_str, "%Y-%m-%d")
        today = datetime.datetime.now().date()
        total_days = int(total_days)
        # If start date is in the future, return 100% progress
        if start_date.date() > today:
            return 100
        days_elapsed = (today - start_date.date()).days
        # If we've passed the total period, return 100%
        if days_elapsed >= total_days:
            return 100
        # Calculate progress percentage
        progress = (days_elapsed / total_days) * 100
        return days_elapsed, progress

    except ValueError:
        print("Error: Invalid date format. Please use YYYY-MM-DD.")
        return 0


def calculate_file_progress(file_path):
    """Calculate progress based on file modification time"""
    try:
        with open(file_path, "r", encoding="utf-8") as f:
            hash_lines = 0
            other_lines = 0
            for line in f:
                # Stop at a marker line such as '#--------'
                if line.lstrip().startswith("#-"):
                    break
                stripped = line.rstrip("\n")
                if stripped.startswith("#"):
                    hash_lines += 1
                elif stripped.strip():
                    other_lines += 1
        total_lines = hash_lines + other_lines
        if total_lines == 0:
            print("Error: No non‑empty lines found in file")
            sys.exit(0)
        progress = (hash_lines / total_lines) * 100
    except FileNotFoundError:
        print(f"Error: File '{file_path}' not found.")
        sys.exit(1)
    return progress, hash_lines, total_lines

def main(args):
    """Main loop"""
    # PROGRESS BAR
    if args.progress_bar:
        # print_title('Progress Bar')
        if args.date and args.total_days:
            # progress based on date (number of days since date vs total days)
            # for example --progress-bar --date 2025-02-02 --total-days 365
            days_elapsed, progress = calculate_progress(args.date, args.total_days)
            print_progress_bar(progress, 100, 60, args.format)
            print(f'{days_elapsed} / {args.total_days}')
        elif args.file:
            # progress based on file (#-commented out lines vs total lines)
            # for example --progress-bar --file /path/to/todo.txt
            progress, hash_lines, total_lines = calculate_file_progress(args.file)
            print_progress_bar(progress, 100, 60, args.format)
            print(f'{hash_lines} / {total_lines}')
        else:
            print("Progress bar requires either --date and --total-days, or --file")
            return

    # GITLAB ISSUES
    if args.gitlab_issues:
        print_title("gitlab issues assigned to you")
        # this function takes either assigned=True, created=True, repos=True
        gitlab_issues = get_gitlab_issues(os.getenv("GITLAB_TOKEN"),
                                    assigned=True)
        gitlab_out_lines = [
            format_bullet_point('▧', colorama.Fore.YELLOW, f'{issue}')
            for issue in gitlab_issues
        ]
        out = format_list(gitlab_out_lines, int(OS_ENVIRON['MAX_LINES']))
        print(out)

    # GITEA ISSUES
    if args.gitea_issues:
        print_title('gitea issues')
        gitea_issues = get_gitea_issues(OS_ENVIRON['GITEA_URL'],
                                      OS_ENVIRON['GITEA_TOKEN'])
        gitea_out_lines = [
            format_bullet_point('▧', colorama.Fore.GREEN, f'{issue}')
            for issue in gitea_issues
        ]
        out = format_list(gitea_out_lines, int(OS_ENVIRON['MAX_LINES']))
        print(out)

    # NEXTCLOUD CALDAV TASKS
    if args.caldav_tasks:
        print_title('nextcloud tasks')
        caldav_tasks = get_caldav_tasks(OS_ENVIRON['CALDAV_URL'],
                                       OS_ENVIRON['CALDAV_USERNAME'],
                                       OS_ENVIRON['CALDAV_PASSWORD'],
                                       int(OS_ENVIRON['CALDAV_MAX_PRIORITY']))
        caldav_tasks_out_lines = [
            format_bullet_point('▧', colorama.Fore.BLUE, f'{task}')
            for task in caldav_tasks
        ]
        out = format_list(caldav_tasks_out_lines, int(OS_ENVIRON['MAX_LINES']))
        print(out)

    # NEXTCLOUD CALDAV EVENTS
    if args.caldav_events:
        print_title('nextcloud events')
        caldav_events = get_caldav_events(OS_ENVIRON['CALDAV_URL'],
                                       OS_ENVIRON['CALDAV_USERNAME'],
                                       OS_ENVIRON['CALDAV_PASSWORD'],
                                       int(OS_ENVIRON['CALDAV_EVENTS_MAX_DAYS_IN_FUTURE']))
        caldav_events_out_lines = [
            format_bullet_point('▧', colorama.Fore.BLUE, f'{task}')
            for task in caldav_events
        ]
        out = format_list(caldav_events_out_lines, int(OS_ENVIRON['MAX_LINES']))
        print(out)

    # TODOTXT TODOS
    if args.todotxt:
        print_title('todos')
        todotxt_todos = get_todo_list(OS_ENVIRON['TODO_TXT_PATH'])
        todotxt_out_lines = [
            format_bullet_point('▧', colorama.Fore.CYAN, f'{todo}')
            for todo in todotxt_todos
        ]
        out = format_list(todotxt_out_lines, int(OS_ENVIRON['MAX_LINES']))
        print(out)

    # TTRSS MARKED ARTICLES
    if args.ttrss_marked:
        print_title('tt-rss marked')
        ttrss_marked_articles = get_ttrss_marked(OS_ENVIRON['TTRSS_URL'],
                                                 OS_ENVIRON['TTRSS_USERNAME'],
                                                 OS_ENVIRON['TTRSS_PASSWORD'],
                                                 OS_ENVIRON['TTRSS_LIMIT'])
        ttrss_marked_out_lines = [
            format_bullet_point('▧', colorama.Fore.MAGENTA, f'{article}')
            for article in ttrss_marked_articles
        ]
        out = format_list(ttrss_marked_out_lines, int(OS_ENVIRON['MAX_LINES']))
        print(out)

    # FILE MODIFICATION TIME
    if args.modtime:
        print_title('modification time check')
        check_mtime(OS_ENVIRON['BACKUP_STATE_FILE'], 86400)

    # UNREAD MAIL
    if args.unread_mail:
        print_title('unread mail')
        unread_mail = get_unread_mail(OS_ENVIRON['IMAP_SERVER'],
                                      993,
                                      OS_ENVIRON['IMAP_USERNAME'],
                                      OS_ENVIRON['IMAP_PASSWORD'],
                                      OS_ENVIRON['IMAP_UNREAD_FOLDERS_LIST']) # comma-separated list
        unread_mail_lines = [
            format_bullet_point('▧', colorama.Fore.YELLOW, f'{article}')
            for article in unread_mail
        ]
        out = format_list(unread_mail_lines, int(OS_ENVIRON['MAX_LINES']))
        print(out)

    # FLAGGED MAIL
    if args.flagged_mail:
        print_title('flagged mail')
        flagged_mail = get_flagged_mail(OS_ENVIRON['IMAP_SERVER'],
                                      993,
                                      OS_ENVIRON['IMAP_USERNAME'],
                                      OS_ENVIRON['IMAP_PASSWORD'],
                                      OS_ENVIRON['IMAP_FLAGGED_FOLDERS_LIST']) # comma-separated list
        flagged_mail_lines = [
            format_bullet_point('▧', colorama.Fore.YELLOW, f'{article}')
            for article in flagged_mail
        ]
        out = format_list(flagged_mail_lines, int(OS_ENVIRON['MAX_LINES']))
        print(out)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Dashboard script for monitoring various services')
    parser.add_argument('--gitlab-issues', action='store_true', help='Show GitLab issues')
    parser.add_argument('--gitea-issues', action='store_true', help='Show Gitea issues')
    parser.add_argument('--caldav-tasks', action='store_true', help='Show CalDAV tasks')
    parser.add_argument('--caldav-events', action='store_true', help='Show CalDAV events')
    parser.add_argument('--todotxt', action='store_true', help='Show todo.txt tasks')
    parser.add_argument('--ttrss-marked', action='store_true', help='Show TT-RSS marked articles')
    parser.add_argument('--modtime', action='store_true', help='Check file modification times')
    parser.add_argument('--unread-mail', action='store_true', help='Show unread mail')
    parser.add_argument('--flagged-mail', action='store_true', help='Show flagged mail')
    parser.add_argument('--progress-bar', action='store_true', help='Show progress bar')
    parser.add_argument('--date', help='Start date for progress bar (YYYY-MM-DD)')
    parser.add_argument('--total-days', type=int, help='Total days for progress bar calculation with --date')
    parser.add_argument('--file', help='File path for progress bar calculation')
    parser.add_argument('--format', dest='format', default='cli', choices=['cli', 'conky'], help='Output format')

    args = parser.parse_args()

    # Validate progress bar arguments
    if args.progress_bar:
        if args.date and args.total_days:
            if not args.date or not args.total_days:
                parser.error("--progress-bar requires --date and --total-days when using date-based calculation")
        elif args.file:
            if not args.file:
                parser.error("--progress-bar requires --file when using file-based calculation")
        elif not args.date and not args.file:
            parser.error("--progress-bar requires either --date and --total-days or --file")

    # If no arguments provided, run all sections
    if not any([args.gitlab_issues, args.gitea_issues, args.caldav_tasks,
                args.caldav_events, args.todotxt, args.ttrss_marked,
                args.modtime, args.unread_mail, args.flagged_mail, args.progress_bar]):
        # Run all sections by default
        args.gitlab_issues = True
        args.gitea_issues = True
        args.caldav_tasks = True
        args.caldav_events = True
        args.todotxt = True
        args.ttrss_marked = True
        args.modtime = True
        args.unread_mail = True
        args.flagged_mail = True
        args.progress_bar = True

    main(args)
